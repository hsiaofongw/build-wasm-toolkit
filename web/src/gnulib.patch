diff --git a/lib/get_stack_top.wat b/lib/get_stack_top.wat
new file mode 100644
index 0000000000..108efb1b39
--- /dev/null
+++ b/lib/get_stack_top.wat
@@ -0,0 +1,7 @@
+(module
+  (global $__stack_pointer (import "env" "__stack_pointer") (mut i32))
+  (func $getllvmallocastacktop (result i32)
+    global.get $__stack_pointer
+  )
+  (export "getllvmallocastacktop" (func $getllvmallocastacktop))
+)
diff --git a/lib/io_adapter.c b/lib/io_adapter.c
new file mode 100644
index 0000000000..c0fdf1931e
--- /dev/null
+++ b/lib/io_adapter.c
@@ -0,0 +1,87 @@
+#include "io_adapter.h"
+
+#include <config.h>
+
+#include "md5.h"
+#include "sha1.h"
+#include "sha256.h"
+#include "sha512.h"
+#include "sm3.h"
+
+#define MAX_RESULT_BUF_SIZE 128
+
+char result_buf[MAX_RESULT_BUF_SIZE];
+
+enum HashProcessStage { HASH_STAGE_COMPLETE = 1, HASH_STAGE_PROCESSING = 0 };
+
+void read_result(void *ctx, uint32_t alg_id, uint32_t stage) {
+  switch (alg_id) {
+    case DIGEST_MD5:
+      md5_read_ctx(ctx, result_buf);
+      break;
+    case DIGEST_SHA1:
+      sha1_read_ctx(ctx, result_buf);
+      break;
+    case DIGEST_SHA224:
+      sha224_read_ctx(ctx, result_buf);
+      break;
+    case DIGEST_SHA256:
+      sha256_read_ctx(ctx, result_buf);
+      break;
+    case DIGEST_SHA384:
+      sha384_read_ctx(ctx, result_buf);
+      break;
+    case DIGEST_SHA512:
+      sha512_read_ctx(ctx, result_buf);
+      break;
+    case DIGEST_SM3:
+      sm3_read_ctx(ctx, result_buf);
+      break;
+    default:
+      return;
+  }
+
+  on_hash_value_update(result_buf, alg_id, stage);
+}
+
+void on_hash_process_block_iterate(uint32_t iter_idx, void *ctx,
+                                   uint32_t alg_id) {
+  uint32_t stride_mask = (2 << 14) - 1;
+  if (iter_idx & stride_mask) {
+    return;
+  }
+
+  read_result(ctx, alg_id, HASH_STAGE_PROCESSING);
+}
+
+void initiate_buffer_hashing(char *msg_buf, uint32_t msg_len, uint32_t alg_id) {
+  switch (alg_id) {
+    case DIGEST_MD5:
+      md5_buffer(msg_buf, msg_len, result_buf);
+      break;
+    case DIGEST_SHA1:
+      sha1_buffer(msg_buf, msg_len, result_buf);
+      break;
+    case DIGEST_SHA224:
+      sha224_buffer(msg_buf, msg_len, result_buf);
+      break;
+    case DIGEST_SHA256:
+      sha256_buffer(msg_buf, msg_len, result_buf);
+      break;
+    case DIGEST_SHA384:
+      sha384_buffer(msg_buf, msg_len, result_buf);
+      break;
+    case DIGEST_SHA512:
+      sha512_buffer(msg_buf, msg_len, result_buf);
+      break;
+    case DIGEST_SM3:
+      sm3_buffer(msg_buf, msg_len, result_buf);
+      break;
+    default:
+      return;
+  }
+
+  on_hash_value_update(result_buf, alg_id, HASH_STAGE_COMPLETE);
+}
+
+void *get_first_usable_address() { return getllvmallocastacktop(); }
diff --git a/lib/io_adapter.h b/lib/io_adapter.h
new file mode 100644
index 0000000000..4bf8c67549
--- /dev/null
+++ b/lib/io_adapter.h
@@ -0,0 +1,21 @@
+#include <stdint.h>
+
+enum DigestId {
+  DIGEST_MD5 = 1,
+  DIGEST_SHA1 = 2,
+  DIGEST_SHA224 = 3,
+  DIGEST_SHA256 = 4,
+  DIGEST_SHA384 = 5,
+  DIGEST_SHA512 = 6,
+  DIGEST_SM3 = 7,
+};
+
+// called within hash iterate function.
+void on_hash_process_block_iterate(uint32_t iter_idx, void *ctx,
+                                   uint32_t alg_id);
+
+// provided by wasm embedder.
+void on_hash_value_update(char *ref_buf, uint32_t alg_id, uint32_t stage);
+
+// provided by linking
+void *getllvmallocastacktop();
diff --git a/lib/md5.c b/lib/md5.c
index 8e02f15d14..3c0ce71c70 100644
--- a/lib/md5.c
+++ b/lib/md5.c
@@ -27,6 +27,8 @@
 #endif
 #include "md5.h"
 
+#include "io_adapter.h"
+
 #include <stdint.h>
 #include <string.h>
 #include <sys/types.h>
@@ -244,6 +246,7 @@ md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)
   ctx->total[0] += lolen;
   ctx->total[1] += (len >> 31 >> 1) + (ctx->total[0] < lolen);
 
+  uint32_t num_iters = 0;
   /* Process all bytes in the buffer with 64 bytes in each round of
      the loop.  */
   while (words < endp)
@@ -375,6 +378,8 @@ md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)
       B += B_save;
       C += C_save;
       D += D_save;
+
+      on_hash_process_block_iterate(num_iters++, ctx, DIGEST_MD5);
     }
 
   /* Put checksum in context given as argument.  */
diff --git a/lib/memcpy.wat b/lib/memcpy.wat
new file mode 100644
index 0000000000..d01a623902
--- /dev/null
+++ b/lib/memcpy.wat
@@ -0,0 +1,10 @@
+(module
+  (memory 2)
+  (func $memcpy (param $dst i32) (param $src i32) (param $len i32) (result i32)
+    local.get $dst
+    local.get $src
+    local.get $len
+    memory.copy
+    local.get $dst
+  )
+)
\ No newline at end of file
diff --git a/lib/sha256.c b/lib/sha256.c
index fe7c5446da..2a42856e54 100644
--- a/lib/sha256.c
+++ b/lib/sha256.c
@@ -38,6 +38,9 @@
 # define SWAP(n) bswap_32 (n)
 #endif
 
+
+#include "io_adapter.h"
+
 #if ! HAVE_OPENSSL_SHA256
 
 /* This array contains the bytes used to pad the buffer to the next
@@ -334,6 +337,7 @@ sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)
                                      D += t1;  H = t0 + t1; \
                                } while(0)
 
+  uint32_t num_iters = 0;
   while (words < endp)
     {
       uint32_t tm;
@@ -419,6 +423,8 @@ sha256_process_block (const void *buffer, size_t len, struct sha256_ctx *ctx)
       f = ctx->state[5] += f;
       g = ctx->state[6] += g;
       h = ctx->state[7] += h;
+
+      on_hash_process_block_iterate(num_iters++, ctx, DIGEST_SHA256);
     }
 }
 
